<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta property="fc:frame" content="vNext">
    <meta property="fc:frame:image" content="https://far-meow.app/og-image.png">
    <meta property="og:image" content="https://far-meow.app/og-image.png"> <!-- Added for social sharing -->
    <meta property="og:title" content="Far Meow - Cat Running Game">
    <meta property="og:description" content="Compete for hourly USDC prizes! üê±‚ö°">
    <meta property="fc:frame:button:1" content="Play Far Meow üê±">
    <meta property="fc:frame:button:1:action" content="link">
    <meta property="fc:frame:button:1:target" content="https://far-meow.app">
    <title>Far Meow: Cat Running Game üê±‚ö°</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@farcaster/frame-sdk@0.1.5/dist/frame-sdk.umd.js"></script>
    <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050510;
            font-family: 'Nunito', sans-serif;
            touch-action: none;
            -webkit-font-smoothing: antialiased;
        }
        
        canvas { display: block; }
        .game-font { font-family: 'Fredoka One', cursive; }

        /* UI Screens */
        .ui-screen {
            transition: opacity 0.3s ease;
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }
        
        .hidden-screen {
            opacity: 0;
            pointer-events: none;
        }

        .active-screen {
            opacity: 1;
            pointer-events: auto;
        }

        /* HUD */
        .hud-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-8px); }
        }
        .animate-float { animation: float 3s ease-in-out infinite; }

        .glass-panel {
            background: rgba(10, 10, 20, 0.8);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(56, 189, 248, 0.3); /* Light Blue Border */
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.1);
            border-radius: 16px;
        }
        
        .neon-text {
            text-shadow: 0 0 10px rgba(56, 189, 248, 0.6);
        }

        /* LEADERBOARD STYLES */
        .leaderboard-container {
            max-height: 400px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(56, 189, 248, 0.3) transparent;
        }
        
        .leaderboard-container::-webkit-scrollbar {
            width: 6px;
        }
        
        .leaderboard-container::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .leaderboard-container::-webkit-scrollbar-thumb {
            background: rgba(56, 189, 248, 0.3);
            border-radius: 3px;
        }
        
        .leaderboard-row {
            transition: background-color 0.2s ease;
        }
        
        .leaderboard-row:hover {
            background: rgba(56, 189, 248, 0.1);
        }
        
        .rank-badge {
            min-width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .rank-1 { background: linear-gradient(135deg, #ffd700, #ffed4e); color: #000; }
        .rank-2 { background: linear-gradient(135deg, #c0c0c0, #e8e8e8); color: #000; }
        .rank-3 { background: linear-gradient(135deg, #cd7f32, #e89b5c); color: #000; }
        .rank-other { background: rgba(56, 189, 248, 0.2); color: #67e8f9; }
    </style>
</head>
<body class="text-white select-none bg-gray-900">

    <!-- Header -->
    <div class="absolute top-0 left-0 w-full h-12 bg-gray-900/90 border-b border-cyan-900/50 z-50 flex items-center px-4 justify-between text-xs text-cyan-400">
        <div class="flex items-center gap-2">
            <div class="w-4 h-4 rounded-full bg-cyan-500 shadow-[0_0_10px_rgba(6,182,212,0.6)]"></div>
            <span id="farcasterStatus">CONNECTING...</span>
        </div>
        <div><span id="walletBalance">-- USDC</span></div>
    </div>

    <canvas id="gameCanvas" class="mt-12"></canvas>

    <!-- 1. LANDING SCREEN -->
    <div id="landingScreen" class="ui-screen active-screen pt-12">
        <div class="absolute top-16 bg-cyan-900/20 border border-cyan-500/50 px-4 py-1 rounded-full flex items-center gap-2">
            <span class="text-xs text-cyan-300 font-bold uppercase">ENDS IN</span>
            <span id="countDown" class="font-mono font-bold text-cyan-100">59:21</span>
        </div>

        <div class="text-center animate-float mt-8">
            <h1 class="text-5xl game-font text-transparent bg-clip-text bg-gradient-to-b from-cyan-300 to-blue-500 neon-text tracking-wide">FAR<br>MEOW</h1>
            <p class="text-cyan-300 font-bold mt-2 tracking-widest text-xs">FARCASTER EDITION</p>
        </div>

        <div class="mt-8 glass-panel p-6 w-11/12 max-w-sm text-center">
            <p class="text-cyan-400 text-xs font-bold uppercase tracking-widest mb-1">HOURLY JACKPOT</p>
            <p class="text-5xl game-font text-white neon-text">$<span id="potValue">1,240</span></p>
            
            <div class="grid grid-cols-3 gap-2 text-center text-xs border-t border-cyan-800/50 pt-4 mt-4">
                <div><div class="text-cyan-500">1ST</div><div class="text-white font-bold">$310</div></div>
                <div><div class="text-cyan-500">TOP 10</div><div class="text-white font-bold">>$55</div></div>
                <div><div class="text-cyan-500">TOP 20</div><div class="text-white font-bold">>$22</div></div>
            </div>
        </div>
        
        <div class="mt-8 w-full px-6 max-w-sm">
            <button onclick="initiatePayment()" class="w-full py-4 rounded-xl font-black text-xl bg-gradient-to-r from-cyan-500 to-blue-600 text-white game-font shadow-[0_0_20px_rgba(6,182,212,0.4)] active:scale-95 transition-transform">
                PLAY NOW <span class="text-sm opacity-80 ml-2">(0.25 USDC)</span>
            </button>
            <p class="text-cyan-400 text-xs mt-2 text-center">Connect wallet to play ‚Ä¢ Top 20 split prize pool</p>
        </div>

        <!-- LEADERBOARD SECTION -->
        <div class="mt-6 glass-panel p-4 w-11/12 max-w-sm">
            <div class="flex items-center justify-between mb-3">
                <h3 class="text-cyan-400 font-bold text-sm uppercase tracking-widest">Top 100 Players</h3>
                <button onclick="refreshLeaderboard()" class="text-cyan-500 text-xs hover:text-cyan-300">
                    <span id="refreshIcon">üîÑ</span>
                </button>
            </div>
            
            <div class="leaderboard-container">
                <div id="leaderboardList" class="space-y-1">
                    <div class="text-center py-8 text-cyan-400 text-sm">
                        Loading leaderboard...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 2. PAYMENT SCREEN -->
    <div id="paymentScreen" class="ui-screen hidden-screen glass-panel z-30 bg-black/90">
        <div class="text-center">
            <div class="w-12 h-12 border-4 border-cyan-500 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
            <h3 class="text-sm text-white">PROCESSING...</h3>
        </div>
    </div>

    <!-- 3. HUD -->
    <div id="hud" class="hud-layer hidden-screen pt-12">
        <div class="absolute top-16 left-4 right-4 flex justify-between items-start">
            <div class="bg-gray-900/60 backdrop-blur px-4 py-2 rounded-full border border-cyan-500/30 flex items-center gap-2">
                <span class="text-xl">üí†</span>
                <span id="scoreDisplay" class="text-xl font-bold text-white game-font">0</span>
            </div>
            <div class="bg-gray-900/60 backdrop-blur px-4 py-2 rounded-full border border-cyan-500/30 text-right">
                <span class="text-cyan-300 text-xs font-bold uppercase">RANK</span>
                <span id="liveRank" class="text-green-400 font-bold game-font ml-2">--</span>
            </div>
        </div>
        <div class="absolute bottom-8 w-full text-center">
             <p class="text-cyan-200/50 text-xs font-bold animate-pulse">TAP TO JUMP</p>
        </div>
    </div>

    <!-- 4. GAME OVER -->
    <div id="gameOverScreen" class="ui-screen hidden-screen z-30 pt-12 bg-black/80 backdrop-blur">
        <div class="glass-panel p-8 rounded-3xl text-center max-w-xs w-full">
            <h2 class="text-3xl text-white game-font mb-1 neon-text">Finished!</h2>
            
            <div class="bg-gray-900/50 rounded-xl p-4 mb-6 border border-cyan-900/50">
                <div class="flex justify-between items-end mb-2 border-b border-cyan-900/50 pb-2">
                    <span class="text-cyan-400 text-sm">SCORE</span>
                    <span id="finalScore" class="text-xl text-white font-bold">0</span>
                </div>
                <div class="flex justify-between items-end">
                    <span class="text-yellow-500 text-sm font-bold">PAYOUT</span>
                    <span id="estPayout" class="text-xl text-yellow-400 font-bold">$23.40</span>
                </div>
            </div>
            
            <button onclick="initiatePayment()" class="w-full py-3 bg-cyan-600 hover:bg-cyan-500 text-white rounded-xl font-bold text-lg mb-3 shadow-lg transition-colors">RETRY</button>
            <button onclick="shareResult()" class="w-full py-3 border border-cyan-700 text-cyan-300 rounded-xl font-bold text-sm hover:bg-cyan-900/30 transition-colors">Share Result</button>
        </div>
    </div>

    <script>
        // ============================================
        // FARCASTER & WALLET INTEGRATION
        // ============================================
        
        const CONFIG = {
            VAULT_CONTRACT: '0xaf08c8f5100Afd8aE30f40751ED85B125b873f77',
            USDC_ADDRESS: '0x036CbD53842c5426634e7929541eC2318f3dCF7e',
            BASE_CHAIN_ID: 84532,
            ENTRY_FEE: '250000',
            API_ENDPOINT: '', // Empty = mock mode for now
            NEYNAR_API_KEY: 'NEYNAR_API_DOCS', // Get free key at https://neynar.com
            MAX_SCORE: 999999,
            MIN_GAME_DURATION: 5000,
            MAX_SUBMISSIONS_PER_HOUR: 10
        };

        let farcasterSDK = null;
        let ethersProvider = null;
        let currentUser = null;
        let vaultContract = null;
        let usdcContract = null;
        let currentPot = 0;
        let currentRoundId = null;
        let gameStartTime = null;
        let isProcessingPayment = false; // Prevent double-spend
        let countdownInterval = null;
        let sessionToken = null; // Backend-issued token after payment
        let submissionCount = 0; // Rate limiting
        let leaderboardData = [];
        
        // ABI for contracts (minimal)
        const VAULT_ABI = [
            "function payEntry() external",
            "function commitScore(bytes32) external", // ADDED
            "function getCurrentRound() view returns (uint256, uint256, uint256, uint256, bool)",
            "function getPlayerScore(address) view returns (uint256)",
            "function claimPrize(uint256) external",
            "function estimatePayout(uint256) view returns (uint256)"
        ];
        
        const ERC20_ABI = [
            "function balanceOf(address) view returns (uint256)",
            "function approve(address spender, uint256 amount) external returns (bool)",
            "function allowance(address owner, address spender) view returns (uint256)"
        ];

        // Initialize Farcaster SDK
        async function initFarcaster() {
            try {
                // Check if running inside Farcaster
                const sdk = window.frameSDK;
                
                if (sdk) {
                    // Inside Farcaster frame
                    await sdk.actions.ready();
                    const context = await sdk.context;
                    currentUser = context.user;
                    
                    if (currentUser) {
                        document.getElementById('farcasterStatus').textContent = `@${currentUser.username}`;
                        
                        // Get wallet from frame SDK
                        ethersProvider = new ethers.providers.Web3Provider(sdk.wallet.ethProvider);
                        farcasterSDK = sdk;
                    }
                } else {
                    // Outside Farcaster - use regular Web3
                    document.getElementById('farcasterStatus').textContent = 'CONNECT WALLET';
                    
                    // Show connect button
                    showConnectWalletButton();
                    return;
                }

                const network = await ethersProvider.getNetwork();
                if (network.chainId !== CONFIG.BASE_CHAIN_ID) {
                    console.warn('Wrong network detected:', network.chainId);
                    document.getElementById('farcasterStatus').textContent = 'SWITCH TO BASE';
                    alert('Please switch to Base network in your wallet.');
                    return;
                }

                if (!CONFIG.VAULT_CONTRACT || CONFIG.VAULT_CONTRACT === '0x...') {
                    console.warn('VAULT_CONTRACT not configured');
                    document.getElementById('farcasterStatus').textContent = 'CONFIG ERROR';
                    return;
                }
                
                const signer = ethersProvider.getSigner();
                vaultContract = new ethers.Contract(CONFIG.VAULT_CONTRACT, VAULT_ABI, signer);
                usdcContract = new ethers.Contract(CONFIG.USDC_ADDRESS, ERC20_ABI, signer);
                
                await verifyPlayer();
                await loadVaultData();
                await updateBalance();
                await loadLeaderboard(); // Add this
                
                setInterval(loadVaultData, 10000);
                setInterval(updateBalance, 30000);
                setInterval(loadLeaderboard, 15000); // Refresh every 15 seconds
                
                console.log('‚úÖ Farcaster initialized:', currentUser.username);
                
            } catch (error) {
                console.error('‚ùå Farcaster init failed:', error);
                document.getElementById('farcasterStatus').textContent = 'ERROR';
            }
        }

        // Add wallet connection for non-Farcaster users
        function showConnectWalletButton() {
            const statusDiv = document.querySelector('#farcasterStatus').parentElement;
            statusDiv.innerHTML = `
                <button onclick="connectWallet()" class="px-4 py-2 bg-cyan-600 hover:bg-cyan-500 rounded-lg text-white font-bold text-xs transition-colors">
                    CONNECT WALLET
                </button>
            `;
        }

        // Connect wallet via MetaMask/Coinbase Wallet
        async function connectWallet() {
            try {
                if (!window.ethereum) {
                    alert('Please install MetaMask or Coinbase Wallet to play!');
                    return;
                }

                // Request wallet connection
                await window.ethereum.request({ method: 'eth_requestAccounts' });
                
                ethersProvider = new ethers.providers.Web3Provider(window.ethereum);
                const signer = ethersProvider.getSigner();
                const address = await signer.getAddress();
                
                // Check network
                const network = await ethersProvider.getNetwork();
                if (network.chainId !== CONFIG.BASE_CHAIN_ID) {
                    // Request network switch
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: '0x14a34' }], // 84532 in hex
                        });
                    } catch (switchError) {
                        // Add network if not exists
                        if (switchError.code === 4902) {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: '0x14a34',
                                    chainName: 'Base Sepolia',
                                    nativeCurrency: {
                                        name: 'ETH',
                                        symbol: 'ETH',
                                        decimals: 18
                                    },
                                    rpcUrls: ['https://sepolia.base.org'],
                                    blockExplorerUrls: ['https://sepolia.basescan.org']
                                }]
                            });
                        }
                    }
                }

                // Try to fetch Farcaster profile from Neynar
                currentUser = await fetchFarcasterProfile(address);
                
                if (currentUser) {
                    document.getElementById('farcasterStatus').textContent = `@${currentUser.username}`;
                } else {
                    document.getElementById('farcasterStatus').textContent = `${address.slice(0, 6)}...${address.slice(-4)}`;
                    currentUser = { 
                        fid: 0, 
                        username: address.slice(0, 8),
                        address: address
                    };
                }

                // Initialize contracts
                const signerInstance = ethersProvider.getSigner();
                vaultContract = new ethers.Contract(CONFIG.VAULT_CONTRACT, VAULT_ABI, signerInstance);
                usdcContract = new ethers.Contract(CONFIG.USDC_ADDRESS, ERC20_ABI, signerInstance);
                
                await loadVaultData();
                await updateBalance();
                await loadLeaderboard();
                
                setInterval(loadVaultData, 10000);
                setInterval(updateBalance, 30000);
                setInterval(loadLeaderboard, 15000);
                
                console.log('‚úÖ Wallet connected:', address);
                
            } catch (error) {
                console.error('‚ùå Wallet connection failed:', error);
                alert('Failed to connect wallet. Please try again.');
            }
        }

        // Fetch Farcaster profile using Neynar API
        async function fetchFarcasterProfile(address) {
            if (!CONFIG.NEYNAR_API_KEY || CONFIG.NEYNAR_API_KEY === 'NEYNAR_API_DOCS') {
                console.log('No Neynar API key configured');
                return null;
            }

            try {
                const response = await fetch(
                    `https://api.neynar.com/v2/farcaster/user/bulk-by-address?addresses=${address}`,
                    {
                        headers: {
                            'api_key': CONFIG.NEYNAR_API_KEY,
                            'accept': 'application/json'
                        }
                    }
                );

                if (!response.ok) {
                    console.warn('Neynar API error:', response.status);
                    return null;
                }

                const data = await response.json();
                
                if (data && data[address] && data[address].length > 0) {
                    const user = data[address][0];
                    return {
                        fid: user.fid,
                        username: user.username,
                        address: address,
                        pfp_url: user.pfp_url
                    };
                }
                
                return null;
                
            } catch (error) {
                console.error('Failed to fetch Farcaster profile:', error);
                return null;
            }
        }

        // Verify player with backend
        async function verifyPlayer() {
            if (!currentUser || !ethersProvider) return;
            
            // Mock mode - skip backend verification
            if (!CONFIG.API_ENDPOINT) {
                console.log('Mock: Player verified');
                return;
            }
            
            try {
                const address = await ethersProvider.getSigner().getAddress();
                
                if (!ethers.utils.isAddress(address)) {
                    throw new Error('Invalid wallet address');
                }

                const response = await fetch(`${CONFIG.API_ENDPOINT}/verify-player`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fid: currentUser.fid,
                        username: currentUser.username,
                        address: address
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Verification failed: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('‚úÖ Player verified:', data);
                
            } catch (error) {
                console.error('‚ùå Verification failed:', error);
            }
        }

        // Load vault data from contract
        async function loadVaultData() {
            if (!vaultContract) return;
            try {
                const roundData = await vaultContract.getCurrentRound();
                
                // REMOVED: isActive check (not in ABI return type)
                
                currentRoundId = roundData[0].toNumber();
                const vaultAmount = ethers.utils.formatUnits(roundData[1], 6);
                const timeRemaining = roundData[3].toNumber();
                
                currentPot = Number.isFinite(parseFloat(vaultAmount))
                    ? parseFloat(vaultAmount)
                    : 0;

                const potDisplay = Math.floor(currentPot).toLocaleString();
                document.getElementById('potValue').textContent = potDisplay;
                document.getElementById('potValueSmall').textContent = potDisplay;
                
                startCountdown(timeRemaining);
                updatePayoutEstimates(currentPot);
                
            } catch (error) {
                console.error('‚ùå Load vault data failed:', error);
            }
        }

        // Start actual countdown timer
        function startCountdown(seconds) {
            if (countdownInterval) clearInterval(countdownInterval);
            
            let remaining = seconds;
            
            const updateDisplay = () => {
                if (remaining <= 0) {
                    clearInterval(countdownInterval);
                    document.getElementById('countDown').textContent = '00:00';
                    return;
                }
                
                const minutes = Math.floor(remaining / 60);
                const secs = remaining % 60;
                document.getElementById('countDown').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                
                remaining--;
            };
            
            updateDisplay();
            countdownInterval = setInterval(updateDisplay, 1000);
        }

        // Update payout estimates
        function updatePayoutEstimates(vaultAmount) {
            const vault = parseFloat(vaultAmount);
            if (!Number.isFinite(vault)) return;

            const elems = document.querySelectorAll('.grid .text-white.font-bold');
            if (elems.length < 3) return;

            // Match Solidity: 1st = 25.5%, 10th = 2.5%, 20th = 2.5%
            elems[0].textContent = `$${Math.floor(vault * 0.255)}`; // 1st Place
            elems[1].textContent = `$${Math.floor(vault * 0.025)}`; // 10th Place (2.5%)
            elems[2].textContent = `$${Math.floor(vault * 0.025)}`; // 20th Place (2.5%)
        }

        // Update USDC balance
        async function updateBalance() {
            if (!usdcContract || !ethersProvider) return;
            try {
                const signer = ethersProvider.getSigner();
                const address = await signer.getAddress();
                const balance = await usdcContract.balanceOf(address);
                const formatted = ethers.utils.formatUnits(balance, 6);
                const num = parseFloat(formatted);
                const safe = Number.isFinite(num) ? num : 0;
                document.getElementById('walletBalance').textContent = `${safe.toFixed(2)} USDC`;
            } catch (error) {
                console.error('‚ùå Balance update failed:', error);
            }
        }

        // Load leaderboard data
        async function loadLeaderboard() {
            // Mock mode - use fake data
            if (!CONFIG.API_ENDPOINT) {
                leaderboardData = [
                    { username: 'Alice', score: 5000, estimatedPayout: 310, fid: 1 },
                    { username: 'Bob', score: 4500, estimatedPayout: 186, fid: 2 },
                    { username: 'Charlie', score: 4000, estimatedPayout: 124, fid: 3 },
                    { username: 'Diana', score: 3500, estimatedPayout: 87, fid: 4 },
                    { username: 'Eve', score: 3000, estimatedPayout: 62, fid: 5 },
                ];
                renderLeaderboard();
                return;
            }
            
            try {
                const response = await fetch(`${CONFIG.API_ENDPOINT}/leaderboard?limit=100`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                leaderboardData = Array.isArray(data.players) ? data.players : [];
                
                renderLeaderboard();
                
            } catch (error) {
                console.error('‚ùå Leaderboard load failed:', error);
                document.getElementById('leaderboardList').innerHTML = 
                    '<div class="text-center py-8 text-red-400 text-sm">Failed to load leaderboard</div>';
            }
        }

        // Refresh leaderboard with animation
        async function refreshLeaderboard() {
            const icon = document.getElementById('refreshIcon');
            icon.style.transform = 'rotate(360deg)';
            icon.style.transition = 'transform 0.5s ease';
            
            await loadLeaderboard();
            
            setTimeout(() => {
                icon.style.transform = 'rotate(0deg)';
            }, 500);
        }

        // Render leaderboard UI
        function renderLeaderboard() {
            const container = document.getElementById('leaderboardList');
            
            if (!leaderboardData || leaderboardData.length === 0) {
                container.innerHTML = 
                    '<div class="text-center py-8 text-cyan-400 text-sm">No players yet. Be the first!</div>';
                return;
            }
            
            let html = '';
            
            leaderboardData.forEach((player, index) => {
                const rank = index + 1;
                const rankClass = rank === 1 ? 'rank-1' : 
                                 rank === 2 ? 'rank-2' : 
                                 rank === 3 ? 'rank-3' : 'rank-other';
                
                const score = Number(player.score) || 0;
                const payout = Number(player.estimatedPayout) || 0;
                // Sanitize username to prevent XSS
                const name = (player.username || player.address?.slice(0, 6) || 'Anonymous').replace(/[<>]/g, '');
                
                // Highlight current user
                const isCurrentUser = currentUser && (
                    player.fid === currentUser.fid || 
                    player.username === currentUser.username
                );
                const highlightClass = isCurrentUser ? 'bg-cyan-900/30 border border-cyan-500/50' : '';
                
                html += `
                    <div class="leaderboard-row flex items-center justify-between p-2 rounded-lg ${highlightClass}">
                        <div class="flex items-center gap-3 flex-1 min-w-0">
                            <div class="rank-badge ${rankClass} text-xs flex-shrink-0">
                                ${rank}
                            </div>
                            <div class="flex-1 min-w-0">
                                <div class="text-white font-bold text-sm truncate">
                                    ${isCurrentUser ? 'üë§ ' : ''}${name}
                                </div>
                                <div class="text-cyan-400 text-xs">
                                    ${score.toLocaleString()} pts
                                </div>
                            </div>
                        </div>
                        <div class="text-right flex-shrink-0">
                            <div class="text-yellow-400 font-bold text-sm">
                                ${payout > 0 ? `$${payout.toFixed(2)}` : '-'}
                            </div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        // Initiate payment and game start
        async function initiatePayment() {
            if (isProcessingPayment) {
                console.warn('Payment already in progress');
                return;
            }

            if (!ethersProvider || !vaultContract || !usdcContract) {
                alert('Please connect your wallet first!');
                if (!farcasterSDK) {
                    await connectWallet();
                }
                return;
            }

            // Check if round is still active
            if (!currentRoundId) {
                alert('No active round. Please wait for the next round.');
                return;
            }
            
            isProcessingPayment = true;
            
            document.getElementById('landingScreen').classList.remove('active-screen');
            document.getElementById('landingScreen').classList.add('hidden-screen');
            document.getElementById('gameOverScreen').classList.remove('active-screen');
            document.getElementById('gameOverScreen').classList.add('hidden-screen');

            const payScreen = document.getElementById('paymentScreen');
            payScreen.classList.remove('hidden-screen');
            payScreen.classList.add('active-screen');

            try {
                const signer = ethersProvider.getSigner();
                const address = await signer.getAddress();
                
                // Validate address
                if (!ethers.utils.isAddress(address)) {
                    throw new Error('Invalid wallet address');
                }

                // Check USDC balance
                const balance = await usdcContract.balanceOf(address);
                if (balance.lt(CONFIG.ENTRY_FEE)) {
                    throw new Error('Insufficient USDC balance. You need at least 0.25 USDC.');
                }
                
                // Check allowance
                const allowance = await usdcContract.allowance(address, CONFIG.VAULT_CONTRACT);
                
                if (allowance.lt(CONFIG.ENTRY_FEE)) {
                    // Request exact amount approval instead of unlimited
                    const approveAmount = ethers.BigNumber.from(CONFIG.ENTRY_FEE).mul(10); // Approve for 10 games
                    
                    // Estimate gas first
                    const gasEstimate = await usdcContract.estimateGas.approve(
                        CONFIG.VAULT_CONTRACT,
                        approveAmount
                    );
                    
                    const approveTx = await usdcContract.approve(
                        CONFIG.VAULT_CONTRACT,
                        approveAmount,
                        { gasLimit: gasEstimate.mul(120).div(100) } // 20% buffer
                    );
                    
                    await approveTx.wait(1); // Wait for 1 confirmation
                }
                
                // Estimate gas for payment
                const gasEstimate = await vaultContract.estimateGas.payEntry();
                
                // Pay entry fee
                const tx = await vaultContract.payEntry({
                    gasLimit: gasEstimate.mul(120).div(100) // 20% buffer
                });
                
                const receipt = await tx.wait(1);
                
                // Verify transaction succeeded
                if (receipt.status !== 1) {
                    throw new Error('Transaction failed');
                }
                
                console.log('‚úÖ Payment successful:', receipt.transactionHash);
                
                // Get session token from backend
                const sessionResponse = await fetch(`${CONFIG.API_ENDPOINT}/create-session`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fid: currentUser.fid,
                        address: address,
                        txHash: receipt.transactionHash,
                        roundId: currentRoundId
                    })
                });
                
                if (sessionResponse.ok) {
                    const sessionData = await sessionResponse.json();
                    sessionToken = sessionData.token;
                } else {
                    console.warn('Failed to create session, continuing anyway');
                }
                
                await updateBalance();
                
                setTimeout(() => {
                    payScreen.classList.remove('active-screen');
                    payScreen.classList.add('hidden-screen');
                    isProcessingPayment = false;
                    startGame();
                }, 800);
                
            } catch (error) {
                console.error('‚ùå Payment failed:', error);
                
                let errorMsg = 'Payment failed. Please try again.';
                
                if (error.code === 'ACTION_REJECTED' || error.code === 4001) {
                    errorMsg = 'Transaction rejected by user.';
                } else if (error.message) {
                    errorMsg = error.message;
                }
                
                alert(errorMsg);
                
                payScreen.classList.remove('active-screen');
                payScreen.classList.add('hidden-screen');
                document.getElementById('landingScreen').classList.add('active-screen');
                document.getElementById('landingScreen').classList.remove('hidden-screen');
                
                isProcessingPayment = false;
            }
        }

        // Submit score to backend and smart contract
        async function submitScore(finalScore) {
            if (!currentUser || !vaultContract || !ethersProvider) {
                return { rank: '--', payout: '0.00' };
            }

            // Rate limiting
            if (submissionCount >= CONFIG.MAX_SUBMISSIONS_PER_HOUR) {
                console.error('‚ùå Rate limit exceeded');
                return { rank: '--', payout: '0.00' };
            }

            // Anti-cheat checks
            const gameDuration = Date.now() - gameStartTime;
            if (gameDuration < CONFIG.MIN_GAME_DURATION) {
                console.error('‚ùå Game too short, likely cheating');
                return { rank: '--', payout: '0.00' };
            }

            if (finalScore > CONFIG.MAX_SCORE || finalScore < 0) {
                console.error('‚ùå Invalid score range');
                return { rank: '--', payout: '0.00' };
            }

            // Sanitize score
            const sanitizedScore = Math.floor(Number(finalScore));
            if (!Number.isFinite(sanitizedScore)) {
                return { rank: '--', payout: '0.00' };
            }
            
            try {
                const secret = ethers.utils.randomBytes(32);
                const secretHex = ethers.utils.hexlify(secret);
                
                const commitment = ethers.utils.keccak256(
                    ethers.utils.defaultAbiCoder.encode(['uint256', 'bytes32'], [sanitizedScore, secretHex])
                );

                const address = await ethersProvider.getSigner().getAddress();
                
                // FIXED: Call commitScore FIRST (step 1 of commit-reveal)
                try {
                    const commitTx = await vaultContract.commitScore(commitment);
                    await commitTx.wait(1);
                    console.log('‚úÖ Score committed on-chain');
                } catch (e) {
                    console.error('‚ùå Commit failed:', e);
                    return { rank: '--', payout: '0.00' };
                }
                
                // Then submit to backend (step 2)
                const response = await fetch(`${CONFIG.API_ENDPOINT}/submit-score`, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': sessionToken ? `Bearer ${sessionToken}` : ''
                    },
                    body: JSON.stringify({
                        fid: currentUser.fid,
                        address: address,
                        score: sanitizedScore,
                        secret: secretHex,
                        commitment: commitment,
                        roundId: currentRoundId,
                        gameDuration: gameDuration,
                        timestamp: Date.now()
                    })
                });

                if (!response.ok) {
                    console.error('‚ùå submit-score HTTP error', response.status);
                    return { rank: '--', payout: '0.00' };
                }
                
                const data = await response.json().catch(() => ({}));
                
                // Backend returns real rank (not random estimate)
                const rank = Number.isFinite(Number(data.rank)) ? Number(data.rank) : 99;
                
                // Get payout from contract
                let payout = '0.00';
                if (rank > 0 && rank <= 20) {
                    try {
                        const payoutRaw = await vaultContract.estimatePayout(rank - 1);
                        payout = ethers.utils.formatUnits(payoutRaw, 6);
                    } catch (e) {
                        console.warn('Failed to estimate payout:', e);
                    }
                }
                
                submissionCount++;
                return { rank, payout };
                
            } catch (error) {
                console.error('‚ùå Score submission failed:', error);
                return { rank: '--', payout: '0.00' };
            }
forge install OpenZeppelin/openzeppelin-contracts-upgradeable@v4.9.3 --no-commit
        }

        // SIMPLIFIED: Share result via Warpcast only
        async function shareResult() {
            const safeScore = Number.isFinite(score) ? score : 0;
            const safePot = Number.isFinite(currentPot) ? Math.floor(currentPot) : 0;
            const shareText = `I just scored ${safeScore} points in Far Meow! üê±‚ö°\n\nCompete for the $${safePot} prize pool!`;
            const embedUrl = 'https://far-meow.app';
            
            // Warpcast compose URL
            const warpcastUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(shareText)}&embeds%5B%5D=${encodeURIComponent(embedUrl)}`;

            // Try SDK first, then fallback
            if (farcasterSDK?.actions?.openUrl) {
                try {
                    await farcasterSDK.actions.openUrl(warpcastUrl);
                    return;
                } catch (e) {
                    console.warn('SDK failed', e);
                }
            }

            // Fallback: open in new window
            window.open(warpcastUrl, '_blank', 'noopener,noreferrer');
        }

        // --- OPTIMIZED NEON SPRITE GENERATOR (The Secret Sauce) ---
        // We draw complex glows ONCE into an offscreen canvas, then just draw that image.
        const sprites = {};

        function createOffscreenSprite(width, height, drawFn) {
            const c = document.createElement('canvas');
            c.width = width;
            c.height = height;
            const ctx = c.getContext('2d');
            drawFn(ctx, width, height);
            return c;
        }

        function initSprites() {
            // 1. NEON CAT (64x64)
            sprites.cat = createOffscreenSprite(80, 80, (ctx, w, h) => {
                const cx = w/2, cy = h/2;
                
                // Outer Glow (Baked in)
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#06b6d4'; // Cyan Glow
                
                // Body
                ctx.fillStyle = '#e0f2fe'; // Almost white
                ctx.beginPath(); 
                ctx.ellipse(cx, cy+5, 18, 14, 0, 0, Math.PI*2); 
                ctx.fill();

                // Head
                ctx.beginPath(); 
                ctx.arc(cx, cy-10, 14, 0, Math.PI*2); 
                ctx.fill();

                // Ears
                ctx.beginPath();
                ctx.moveTo(cx-12, cy-18); ctx.lineTo(cx-16, cy-28); ctx.lineTo(cx-4, cy-20);
                ctx.moveTo(cx+12, cy-18); ctx.lineTo(cx+16, cy-28); ctx.lineTo(cx+4, cy-20);
                ctx.fill();
                
                // Turn off heavy shadow for details
                ctx.shadowBlur = 0;
                
                // Helmet (Semi-transparent)
                ctx.fillStyle = 'rgba(103, 232, 249, 0.3)';
                ctx.strokeStyle = 'rgba(103, 232, 249, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(cx, cy-10, 18, 0, Math.PI*2); 
                ctx.fill(); ctx.stroke();

                // Face Details
                ctx.fillStyle = '#083344';
                ctx.beginPath(); ctx.arc(cx-5, cy-10, 2, 0, Math.PI*2); ctx.arc(cx+5, cy-10, 2, 0, Math.PI*2); ctx.fill(); // Eyes
                
                // Jetpack
                ctx.fillStyle = '#f472b6'; // Pink
                ctx.fillRect(cx-12, cy, 4, 10);
                ctx.fillRect(cx+8, cy, 4, 10);
            });

            // 2. NEON FISH (Coin)
            sprites.fish = createOffscreenSprite(60, 60, (ctx, w, h) => {
                const cx = w/2, cy = h/2;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#fbbf24'; // Amber glow
                
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(cx, cy, 12, 0, Math.PI*2); // Coin shape
                ctx.stroke();
                
                ctx.fillStyle = '#fbbf24';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('$', cx, cy+1);
            });

            // 3. NEON OBSTACLE (Triangle)
            sprites.obstacle = createOffscreenSprite(60, 60, (ctx, w, h) => {
                const cx = w/2, cy = h/2;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#f43f5e'; // Rose glow
                
                ctx.strokeStyle = '#f43f5e';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(cx, cy-20);
                ctx.lineTo(cx+18, cy+15);
                ctx.lineTo(cx-18, cy+15);
                ctx.closePath();
                ctx.stroke();
                
                // Inner fill opacity
                ctx.fillStyle = 'rgba(244, 63, 94, 0.2)';
                ctx.fill();
            });
        }

        // ============================================
        // OPTIMIZED GAME ENGINE
        // ============================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { 
            alpha: false, 
            desynchronized: true, // Better performance
            willReadFrequently: false 
        });
        
        let cw, ch, laneWidth;
        
        let gameState = 'MENU'; 
        let frameId;
        let lastTime = 0;
        let gameSpeed = 300; // px per sec
        let score = 0;
        let lastLeaderboardUpdate = 0;
        let currentRank = '--';
        
        let player;
        let obstacles = [];
        let collectibles = [];
        let particles = [];
        let backgroundOffset = 0;
        
        // Colors
        const colors = {
            bg: '#050510', 
            grid: '#1e293b',
            gridLight: '#0ea5e9'
        };

        let touchStartX = 0;
        let touchStartY = 0;
        
        window.addEventListener('resize', resizeCanvas);
        document.addEventListener('keydown', handleInput);
        
        canvas.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, {passive: false});
        
        canvas.addEventListener('touchend', e => {
            if (gameState !== 'PLAYING') return;
            const touchEndX = e.changedTouches[0].screenX;
            const touchEndY = e.changedTouches[0].screenY;
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            
            if (Math.abs(dx) < 30 && Math.abs(dy) < 30) {
                player.jump(); return;
            }
            if (Math.abs(dx) > Math.abs(dy)) {
                if (Math.abs(dx) > 20) {
                    if (dx > 0) player.moveRight();
                    else player.moveLeft();
                }
            } else {
                if (dy < -20) player.jump();
            }
        }, {passive: false});

        function handleInput(e) {
            if (gameState !== 'PLAYING') return;
            if (e.key === 'ArrowLeft') player.moveLeft();
            if (e.key === 'ArrowRight') player.moveRight();
            if (e.key === 'ArrowUp' || e.key === ' ') player.jump();
        }

        function resizeCanvas() {
            cw = window.innerWidth;
            ch = window.innerHeight - 48;
            canvas.width = cw;
            canvas.height = ch;
            
            const maxPlayWidth = 600;
            const actualPlayWidth = Math.min(cw, maxPlayWidth);
            laneWidth = actualPlayWidth / 3;
        }

        // --- Classes ---

        class Player {
            constructor() { this.reset(); }
            reset() {
                this.lane = 1;
                this.targetLane = 1;
                this.laneX = this.getLaneCenter(1);
                this.x = this.laneX;
                this.y = ch - ch * 0.2; 
                this.jumping = false;
                this.jumpHeight = 0;
                this.jumpVel = 0;
                this.jumpGravity = 1200;
                this.jumpForce = 600;
                this.bobPhase = 0;
            }
            getLaneCenter(laneIndex) {
                const totalWidth = Math.min(cw, 600);
                const margin = (cw - totalWidth) / 2;
                return margin + (laneIndex * laneWidth) + (laneWidth / 2);
            }
            moveLeft() { if (this.targetLane > 0) this.targetLane--; }
            moveRight() { if (this.targetLane < 2) this.targetLane++; }
            jump() { if (!this.jumping) { this.jumping = true; this.jumpVel = -this.jumpForce; } }
            
            update(dt) {
                const targetX = this.getLaneCenter(this.targetLane);
                this.x += (targetX - this.x) * 15 * dt; 

                if (this.jumping) {
                    this.jumpVel += this.jumpGravity * dt;
                    this.jumpHeight -= this.jumpVel * dt; 
                    if (this.jumpHeight <= 0) {
                        this.jumpHeight = 0;
                        this.jumping = false;
                        spawnParticles(this.x, this.y, 'dust', 4);
                    }
                }
                this.bobPhase += 10 * dt;
            }

            draw(ctx) {
                const yOffset = -this.jumpHeight;
                const bob = this.jumping ? 0 : Math.sin(this.bobPhase) * 5;
                
                // Draw cached sprite centered
                const size = 80; 
                ctx.drawImage(sprites.cat, this.x - size/2, this.y + yOffset + bob - size/2);
                
                // Engine Flame if jumping
                if (this.jumping) {
                    ctx.fillStyle = '#f472b6';
                    ctx.globalAlpha = 0.7;
                    const flameH = Math.random() * 20 + 10;
                    ctx.beginPath();
                    ctx.ellipse(this.x - 12, this.y + yOffset + 15, 3, flameH, 0, 0, Math.PI*2);
                    ctx.ellipse(this.x + 8, this.y + yOffset + 15, 3, flameH, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }
            }
        }

        class Obstacle {
            constructor() { this.active = false; }
            spawn(laneIndex) {
                this.laneIndex = laneIndex;
                this.x = player.getLaneCenter(laneIndex);
                this.y = -100;
                this.active = true;
            }
            update(dt) {
                this.y += gameSpeed * dt;
                if (this.y > ch + 100) this.active = false;
            }
            draw(ctx) {
                const size = 60;
                ctx.drawImage(sprites.obstacle, this.x - size/2, this.y - size/2);
            }
        }

        class Collectible {
            constructor() { this.active = false; }
            spawn(laneIndex) {
                this.laneIndex = laneIndex;
                this.x = player.getLaneCenter(laneIndex);
                this.y = -100;
                this.active = true;
                this.bobOffset = Math.random() * 10;
            }
            update(dt) {
                this.y += gameSpeed * dt;
                if (this.y > ch + 100) this.active = false;
            }
            draw(ctx) {
                const bob = Math.sin(Date.now() / 200 + this.bobOffset) * 5;
                const size = 60;
                ctx.drawImage(sprites.fish, this.x - size/2, this.y - size/2 + bob);
            }
        }

        class Particle {
            constructor() { this.active = false; }
            spawn(x, y, type) {
                this.x = x; this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 100 + 50;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.color = type === 'dust' ? '#22d3ee' : '#fbbf24';
                this.active = true;
            }
            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= 3 * dt;
                if (this.life <= 0) this.active = false;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, 3, 3); // Simple squares are fastest
                ctx.globalAlpha = 1.0;
            }
        }

        // --- Pooling ---
        const obstaclePool = [];
        const collectiblePool = [];
        const particlePool = [];

        function spawnParticles(x, y, type, count) {
            for(let i=0; i<count; i++) {
                let p = particlePool.length > 0 ? particlePool.pop() : new Particle();
                p.spawn(x, y, type);
                particles.push(p);
            }
        }
        function getObstacle(lane) {
            let o = obstaclePool.length > 0 ? obstaclePool.pop() : new Obstacle();
            o.spawn(lane);
            return o;
        }
        function getCollectible(lane) {
            let c = collectiblePool.length > 0 ? collectiblePool.pop() : new Collectible();
            c.spawn(lane);
            return c;
        }

        // --- Loop ---

        function initGame() {
            initSprites();
            resizeCanvas();
            
            if (!player) player = new Player();
            player.reset();
            
            obstacles = [];
            collectibles = [];
            particles = [];

            score = 0;
            gameSpeed = 300; 
            lastLeaderboardUpdate = 0;
            updateHUD();
        }

        function update(dt) {
            gameSpeed += 5 * dt; 
            backgroundOffset += gameSpeed * dt;
            
            player.update(dt);
            
            // Update live leaderboard every 3 seconds
            lastLeaderboardUpdate += dt;
            if (lastLeaderboardUpdate > 3) {
                lastLeaderboardUpdate = 0;
                updateLiveRank();
            }

            // Optimized spawning with difficulty curve
            const spawnChance = Math.min(0.02 + (score / 100000), 0.05);
            if (Math.random() < spawnChance) {
                const lane = Math.floor(Math.random() * 3);
                const safe = ![...obstacles, ...collectibles].some(e => e.laneIndex === lane && e.y < 100);
                if (safe) {
                    // More coins at start, more obstacles later
                    const coinChance = Math.max(0.6 - (score / 5000), 0.3);
                    if (Math.random() < coinChance) collectibles.push(getCollectible(lane));
                    else obstacles.push(getObstacle(lane));
                }
            }

            [obstacles, collectibles, particles].forEach(list => {
                for (let i = list.length - 1; i >= 0; i--) {
                    let e = list[i];
                    e.update(dt);
                    if (!e.active) {
                        if(list === obstacles) obstaclePool.push(e);
                        if(list === collectibles) collectiblePool.push(e);
                        if(list === particles) particlePool.push(e);
                        list.splice(i, 1);
                    }
                }
            });

            checkCollisions();
        }

        function checkCollisions() {
            // Optimized collision detection with early exit
            const playerY = player.y - player.jumpHeight;
            
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const c = collectibles[i];
                if (!c.active) continue;
                
                const dist = Math.hypot(player.x - c.x, playerY - c.y);
                if (dist < 40) {
                    c.active = false;
                    score += 100;
                    updateHUD();
                    spawnParticles(c.x, c.y, 'gold', 5);
                }
            }

            for (let i = 0; i < obstacles.length; i++) {
                const o = obstacles[i];
                if (!o.active) continue;
                
                // Skip if player is high enough
                if (player.jumpHeight > 60) continue;
                
                if (Math.abs(player.x - o.x) < 25 && Math.abs(playerY - o.y) < 35) {
                    gameOver();
                    return;
                }
            }
        }

        function draw() {
            // Clear with performance optimization
            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, cw, ch);

            const totalWidth = Math.min(cw, 600);
            const margin = (cw - totalWidth) / 2;

            // Grid Floor (Perspective Hack) - Optimized
            ctx.strokeStyle = colors.grid;
            ctx.lineWidth = 1;
            ctx.beginPath();
        // Cleanup on unload
        window.addEventListener('beforeunload', () => {
            if (countdownInterval) clearInterval(countdownInterval);
        });     const x = margin + (i * laneWidth);
    </script>   ctx.moveTo(x, 0); ctx.lineTo(x, ch);
</body>     }
</html>     
            // Horizontal Moving Lines with speed effect
            const gridSize = 80;
            const offset = backgroundOffset % gridSize;
            for(let y = offset; y < ch; y += gridSize) {
                ctx.moveTo(margin, y); ctx.lineTo(margin + totalWidth, y);
            }
            ctx.stroke();

            // Side Glows with pulsing effect
            const pulse = Math.sin(Date.now() / 500) * 0.05 + 0.1;
            ctx.fillStyle = colors.gridLight;
            ctx.globalAlpha = pulse;
            ctx.fillRect(margin - 2, 0, 2, ch);
            ctx.fillRect(margin + totalWidth, 0, 2, ch);
            ctx.globalAlpha = 1.0;

            // Optimized rendering with depth sorting
            const renderList = [player, ...obstacles, ...collectibles];
            renderList.sort((a, b) => a.y - b.y);
            
            // Batch render by type for better performance
            renderList.forEach(e => e.draw(ctx));
            
            // Render particles last (alpha blending)
            if (particles.length > 0) {
                particles.forEach(p => p.draw(ctx));
            }
        }

        function loop(timestamp) {
            if (gameState !== 'PLAYING') return;
            if (!lastTime) lastTime = timestamp;
            const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
            lastTime = timestamp;
            update(dt);
            draw();
            frameId = requestAnimationFrame(loop);
        }

        // --- UI ---
        function startGame() {
            // Clear previous game state
            if (player) player.reset();
            obstacles = [];
            collectibles = [];
            particles = [];
            score = 0;
            gameSpeed = 300;
            lastLeaderboardUpdate = 0;
            
            initGame();
            gameState = 'PLAYING';
            gameStartTime = Date.now(); // Track start time
            
            document.getElementById('hud').classList.remove('hidden-screen');
            lastTime = 0;
            requestAnimationFrame(loop);
        }

        function updateHUD() {
            document.getElementById('scoreDisplay').innerText = score;
        }
        
        // Update live leaderboard rank
        async function updateLiveRank() {
            if (!currentUser || score === 0) return;
            
            try {
                const response = await fetch(`${CONFIG.API_ENDPOINT}/live-rank`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fid: currentUser.fid,
                        score: score
                    })
                });
                
                if (!response.ok) {
                    console.warn('live-rank HTTP error', response.status);
                    return;
                }

                const data = await response.json().catch(() => ({}));
                const rankValue = Number(data.rank);
                if (!Number.isFinite(rankValue) || rankValue <= 0) return;

                currentRank = rankValue;
                
                const rankEl = document.getElementById('liveRank');
                rankEl.textContent = `#${currentRank}`;
                
                // Color based on rank
                if (currentRank <= 5) {
                    rankEl.className = 'text-yellow-400 font-bold game-font ml-2';
                } else if (currentRank <= 20) {
                    rankEl.className = 'text-green-400 font-bold game-font ml-2';
                } else {
                    rankEl.className = 'text-cyan-400 font-bold game-font ml-2';
                }
            } catch (error) {
                console.error('‚ùå Live rank update failed:', error);
            }
        }

        async function gameOver() {
            gameState = 'GAMEOVER';
            cancelAnimationFrame(frameId);
            
            document.getElementById('finalScore').innerText = score;
            document.getElementById('hud').classList.add('hidden-screen');
            
            // Submit final score
            const result = await submitScore(score);
            
            // Update payout estimate
            const estRank = Number(result.rank);
            const estPayout = Number.parseFloat(result.payout);
            if (Number.isFinite(estRank) && estRank > 0 && estRank <= 20 && Number.isFinite(estPayout)) {
                document.getElementById('estPayout').textContent = `$${estPayout.toFixed(2)}`;
            } else {
                document.getElementById('estPayout').textContent = '$0.00';
            }
            
            const go = document.getElementById('gameOverScreen');
            go.classList.remove('hidden-screen');
            go.classList.add('active-screen');
            
            // Clear session token after game ends
            sessionToken = null;
        }

        // Initialize on load
        window.addEventListener('load', async () => {
            resizeCanvas();
            await initFarcaster();
            
            // If not in Farcaster, still load leaderboard
            if (!currentUser) {
                await loadLeaderboard();
            }
        });

        // Cleanup on unload
        window.addEventListener('beforeunload', () => {
            if (countdownInterval) clearInterval(countdownInterval);
        });
    </script>
</body>
</html>